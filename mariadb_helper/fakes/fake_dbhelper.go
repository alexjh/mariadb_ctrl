// This file was generated by counterfeiter
package fakes

import (
	"github.com/cloudfoundry/mariadb_ctrl/mariadb_helper"
	"sync"
)

type FakeDBHelper struct {
	StartMysqldInModeStub        func(command string) error
	startMysqldInModeMutex       sync.RWMutex
	startMysqldInModeArgsForCall []struct {
		command string
	}
	startMysqldInModeReturns struct {
		result1 error
	}
	StopMysqldStub        func() error
	stopMysqldMutex       sync.RWMutex
	stopMysqldArgsForCall []struct{}
	stopMysqldReturns     struct {
		result1 error
	}
	UpgradeStub        func() (output string, err error)
	upgradeMutex       sync.RWMutex
	upgradeArgsForCall []struct{}
	upgradeReturns     struct {
		result1 string
		result2 error
	}
	IsDatabaseReachableStub        func() bool
	isDatabaseReachableMutex       sync.RWMutex
	isDatabaseReachableArgsForCall []struct{}
	isDatabaseReachableReturns     struct {
		result1 bool
	}
}

func (fake *FakeDBHelper) StartMysqldInMode(command string) error {
	fake.startMysqldInModeMutex.Lock()
	defer fake.startMysqldInModeMutex.Unlock()
	fake.startMysqldInModeArgsForCall = append(fake.startMysqldInModeArgsForCall, struct {
		command string
	}{command})
	if fake.StartMysqldInModeStub != nil {
		return fake.StartMysqldInModeStub(command)
	} else {
		return fake.startMysqldInModeReturns.result1
	}
}

func (fake *FakeDBHelper) StartMysqldInModeCallCount() int {
	fake.startMysqldInModeMutex.RLock()
	defer fake.startMysqldInModeMutex.RUnlock()
	return len(fake.startMysqldInModeArgsForCall)
}

func (fake *FakeDBHelper) StartMysqldInModeArgsForCall(i int) string {
	fake.startMysqldInModeMutex.RLock()
	defer fake.startMysqldInModeMutex.RUnlock()
	return fake.startMysqldInModeArgsForCall[i].command
}

func (fake *FakeDBHelper) StartMysqldInModeReturns(result1 error) {
	fake.StartMysqldInModeStub = nil
	fake.startMysqldInModeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDBHelper) StopMysqld() error {
	fake.stopMysqldMutex.Lock()
	defer fake.stopMysqldMutex.Unlock()
	fake.stopMysqldArgsForCall = append(fake.stopMysqldArgsForCall, struct{}{})
	if fake.StopMysqldStub != nil {
		return fake.StopMysqldStub()
	} else {
		return fake.stopMysqldReturns.result1
	}
}

func (fake *FakeDBHelper) StopMysqldCallCount() int {
	fake.stopMysqldMutex.RLock()
	defer fake.stopMysqldMutex.RUnlock()
	return len(fake.stopMysqldArgsForCall)
}

func (fake *FakeDBHelper) StopMysqldReturns(result1 error) {
	fake.StopMysqldStub = nil
	fake.stopMysqldReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDBHelper) Upgrade() (output string, err error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.upgradeArgsForCall = append(fake.upgradeArgsForCall, struct{}{})
	if fake.UpgradeStub != nil {
		return fake.UpgradeStub()
	} else {
		return fake.upgradeReturns.result1, fake.upgradeReturns.result2
	}
}

func (fake *FakeDBHelper) UpgradeCallCount() int {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	return len(fake.upgradeArgsForCall)
}

func (fake *FakeDBHelper) UpgradeReturns(result1 string, result2 error) {
	fake.UpgradeStub = nil
	fake.upgradeReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) IsDatabaseReachable() bool {
	fake.isDatabaseReachableMutex.Lock()
	defer fake.isDatabaseReachableMutex.Unlock()
	fake.isDatabaseReachableArgsForCall = append(fake.isDatabaseReachableArgsForCall, struct{}{})
	if fake.IsDatabaseReachableStub != nil {
		return fake.IsDatabaseReachableStub()
	} else {
		return fake.isDatabaseReachableReturns.result1
	}
}

func (fake *FakeDBHelper) IsDatabaseReachableCallCount() int {
	fake.isDatabaseReachableMutex.RLock()
	defer fake.isDatabaseReachableMutex.RUnlock()
	return len(fake.isDatabaseReachableArgsForCall)
}

func (fake *FakeDBHelper) IsDatabaseReachableReturns(result1 bool) {
	fake.IsDatabaseReachableStub = nil
	fake.isDatabaseReachableReturns = struct {
		result1 bool
	}{result1}
}

var _ mariadb_helper.DBHelper = new(FakeDBHelper)
